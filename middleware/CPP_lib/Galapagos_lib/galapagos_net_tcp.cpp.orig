//
// async_tcp_echo_server.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2019 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//


#include "galapagos_net_tcp.hpp"


using namespace galapagos::net::tcp;


session::session(boost::asio::ip::tcp::socket * socket)
    :galapagos::streaming_core(-1)
{

  
      socket_ = socket;
      s_axis_ptr = std::make_unique<galapagos::stream>();
      m_axis_ptr = std::make_unique<galapagos::stream>();

}


void session::send(char * data, int size, short dest){


    in->write(data, size, dest);

}


void session::set_id(short _id){
    
    id= _id;


}

void session::start()
{
    read = true;   
    write = true;

    std::thread t_read(&session::do_read, this);
    std::thread t_write(&session::do_write, this);
    t_read.detach();
    t_write.detach();
}


void session::do_read()
{
    auto self(shared_from_this());
    int length;
    
    while(read){
       
        socket_->wait(boost::asio::ip::tcp::socket::wait_read);
        int avail = socket_->available();
        if(avail>0){
            boost::system::error_code error;
            length = socket_->read_some(boost::asio::buffer(data_, avail), error);
            std::cout << "HI data is " << self->data_ <<  std::endl;
        }
    }
}


void session::do_write()
{
    auto self(shared_from_this());
    std::cout << "in write" << std::endl;
    int dest;

    while(write){
        if(vect.size() == 0)
            vect = out->read(&dest);
   
        std::cout << "after try to read" << std::endl;
   
        std::unique_ptr<char[]> data = std::make_unique<char[]>(vect.size()*8 + sizeof(short));
        memcpy(data.get(), (char *)&dest, sizeof(short));
        char * payload = data.get() + sizeof(short);
        memcpy(payload, vect.data(), vect.size()*8);
        boost::asio::write(*(socket_), boost::asio::buffer(data.get(), vect.size()*8 + sizeof(short)));
    }

}


void session_container::session_container(galapagos::stream * in,
                                          galapagos::stream * out,
                                          std::vector <string> _kernel_info_table,
                                          std::string my_address
            
        ){



    std::vector<std::string>::iterator it;
    ip_addrs.push_back(my_address);



    //initialize ip_tables;
    for(int i=0; i<kernel_info_table.size(); i++){
        kernel_info_table.push_back(_kernel_info_table[i]);
        it=std::find(ip_addrs.begin(), ip_addrs.end(), _kernel_info_table[i]);
        if(it == ip_addrs.end())
            ip_addrs.push_back(_kernel_info_table[i]);
    }

    
    
    //add native interface to routers
    //
    //
    router_in = std::make_unique<galapagos::router_net_in>(ip_addrs);
    router_out = std::make_unique<galapagos::router_net_out>(ip_addrs);
    
    router_in->add_socket(interf);
    router_out->add_socket(interf);
}

void session_container::add_session(boost::asio::ip::tcp::socket * socket){


    //get mutex
    std::lock_guard <std::mutex> lock(*ip_addrs_mutex);
    
    sockets->push_back(std::move(*socket));
    my_sessions.push_back(std::make_shared<session>(&((*sockets)[sockets->size()-1])));
    std::string ip_addr = (*sockets)[sockets->size()-1].remote_endpoint().address().to_string();
    address_map[ip_addr] = my_sessions.size()-1;
    my_sessions[my_sessions.size()-1]->set_id(ip_addrs.size()-1);
    router_in->add_kernel(my_sessions[my_sessions.size()-1]);
    router_out->add_kernel(my_sessions[my_sessions.size()-1]);
    my_sessions[my_sessions.size()-1]->start();

}

bool session_container::find(std::string _ip_addr){


    std::map<std::string, int i>::iterator it;
    it = std::find(address_map.begin(), address_map.end(), _ip_addr);

    if(it == address_map.end())
        return false;
    else 
        return true;

}

std::string session_container::get_ip_addr(short dest){


    return kernel_info_table[dest];

}


bool session_container::send(std::string ip_addr, char * data, int size, short dest){


    find(ip_addr);
    if(!find)
        return false;

    my_sessions[address_map[ip_addr]]->send(data, size, dest);

    return true;
}



accept_server::accept_server(boost::asio::io_context *io_context, 
                                                  short port,  
                                                  galapagos::sesssion_container * _sessions)
    : acceptor_(*io_context, boost::asio::ip::tcp::endpoint(boost::asio::ip::tcp::v4(), port))
{
   
    sessions = _sessions;
    do_accept(); 
      
      
    std::thread t_accept(&accept_server::accept,this);
    t_accept.detach();
}

void accept_server::accept(){

    do_accept();

}

void accept_server::do_accept()
{
      std::cout << "IN ACCEPT" << std::endl;
      acceptor_.async_accept(
        [this](boost::system::error_code ec, boost::asio::ip::tcp::socket socket)
        {
          if (!ec)
          {
            sessions->add_session(&socket);
          }

          do_accept();
        });
}
 

send_server::send_server(short _port, boost::asio::io_context * _io_context, galapagos::session_container * _sessions){

    port = _port;
    io_context = _io_context;
    sessions = _sessions;
    std::thread t_send(&send_server::send_loop,this);
    t_send.detach();
}



void send_server::send_loop(){

    short dest;
    while(1){
        {
            std::lock_guard<std::mutex> guard(mutex);
            if(_done)
                break;
        }

        std::vector<ap_uint<PACKET_DATA_LENGTH> > data_vect = in->read(&dest);
        send(data_vect.data(), data_vect.size * 8, dest);        

    }

}

  
void server_send::send(char * data, int size, short dest){
    
      
    std::string ip_addr = sessions->get_ip_addr(dest);
    bool found = sessions->write(ip_addr, data, size, dest);
      
      
      if(!found){
          
          boost::asio::ip::tcp::socket s(io_context);
          boost::asio::ip::tcp::resolver resolver(io_context);
          std::ostringstream convert;
          convert << port;
          std::string port_str = convert.str();
          boost::asio::connect(s, resolver.resolve(port_str, ip_addr.to_string()));
          sessions.add_session(&s);

      }

}

server::server(short port, std::vector <std::string> kernel_info_table, std::string my_address, bool enabled=true){
   
    sc_ptr = std::make_unique<session_container>(kernel_info_table, my_address);
    ss_ptr = std::make_unique<server_send>(port, &io_context, sc_ptr.get()); 
    if(enabled){
        as_ptr = std::make_unique<accept_server>(&io_context, port, sc_ptr.get());
    }
    
    io_context.run();

}

void galapagos::net::tcp::interface::interface(short id_, galapagos::stream * in_, galapagos::stream * out_)
    :galapagos::streaming_core(id_,in_, out_);
{;}



void galapagos::net::tcp::tcp(int num_ports,
                              short port,
                              galapagos::stream * in, 
                              galapagos::stream * out, 
                              std::mutex * _done_mutex, 
                              bool * _done,
                              std::vector <std::string> kern_info_table,
                              bool _server_enabled=true)
                              :router_in(kern_info_table)   
                              :router_out(kern_info_table)   
                              :tcp_server(port, server_enabled, &router)
                              :interf(0, in, out)
{
    
    router_in.add_socket(interf);
    router_out.add_socket(interf);

    it = std::find(ip_addrs.begin(), ip_addrs.end(), _kern_info_table[i]);
    if(it == ip_addrs.end()){
        ip_addrs.push_back(_kern_info_table[i]); 
    }


}


int main(int argc, char* argv[])
{
  try
  {
    if (argc != 2)
    {
      std::cerr << "Usage: async_tcp_echo_server <port>\n";
      return 1;
    }


    galapagos::net::tcp::server s(std::atoi(argv[1]));
    

  }
  catch (std::exception& e)
  {
    std::cerr << "Exception: " << e.what() << "\n";
  }

  return 0;
}
