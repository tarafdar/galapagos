//
// async_tcp_echo_server.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2019 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <cstdlib>
#include <iostream>
#include <thread>
#include <memory>
#include <utility>
#include <boost/asio.hpp>

#include "galapagos_stream.hpp"

using boost::asio::ip::tcp;

//class write_session
//  : public std::enable_shared_from_this<write_session>
//{
//public:
//  write_session(tcp::socket * socket, std::mutex mutex)
//  {
//  
//      socket_ = socket; 
//      socket_mutex = mutex;
//  }
//
//  void start()
//  {
//    do_write();  
//  }
//
//  galapagos::stream m_axis;
//private:
//
//  void do_write()
//  {
//    auto self(shared_from_this());
//    std::cout << "in write" << std::endl;
//    if(vect.size() == 0)
//        vect = m_axis.vector_read();
//   
//   
//    {
//        std::lock_guard<std::mutex> lock(*socket_mutex);
//    boost::asio::async_write(*socket_, boost::asio::buffer(vect.data(), vect.size() * 8),
//        [this, self](boost::system::error_code ec, std::size_t /*length*/)
//        {
//          if (!ec)
//          {
//            std::cout << "write clearning" << std::endl;
//          }
//        });
//
//     }
//  }
//
//  tcp::socket * socket_;
//  enum { max_length = 1024 };
//  char data_[max_length];
//  std::vector <ap_uint <PACKET_DATA_LENGTH> > vect;
//};

class read_session
  : public std::enable_shared_from_this<read_session>
{
public:
  read_session(tcp::socket * socket)
    //: socket_(std::move(socket))
  {
  
      socket_ = socket; 
  }

  void start()
  {
    read = true;   

    std::thread t(&read_session::do_read, this);
    //std::thread t2(&read_session::do_write, this);
    t.detach();
    //t2.join();
    //    do_read();  
  }

  galapagos::stream s_axis;
  galapagos::stream m_axis;
private:
  void do_read()
  {
    auto self(shared_from_this());
    int length;
    //{
        //std::lock_guard<std::mutex> lock(*socket_mutex);
    while(read){
       
        socket_->wait(boost::asio::ip::tcp::socket::wait_read);
        int avail = socket_->available();
        if(avail>0){
            boost::system::error_code error;
            length = socket_->read_some(boost::asio::buffer(data_, avail), error);
            std::cout << "HI data is " << self->data_ <<  std::endl;
        }
    }
        //socket_->async_read_some(boost::asio::buffer(data_, max_length),
        //    [this, self](boost::system::error_code ec, std::size_t length)
        //    {
        //      if (!ec)
        //      {
        //      std::cout << "HI data is " << self->data_ <<  std::endl;
        //      //do_write(length);
        //      }
        //      else{
        //        std::cout << "in else " << std::endl;

        //      }
        //      if(self->read)
        //          do_read();
        //    });
    //}
  }
  void do_write()
  {
    auto self(shared_from_this());
    std::cout << "in write" << std::endl;
    if(vect.size() == 0)
        vect = m_axis.vector_read();
   
    std::cout << "after try to read" << std::endl;

    //{
    //    std::lock_guard<std::mutex> lock(*socket_mutex);

    //boost::asio::async_write(*socket_, boost::asio::buffer(vect.data(), vect.size() * 8),
    //    [this, self](boost::system::error_code ec, std::size_t /*length*/)
    //    {
    //      if (!ec)
    //      {
    //        std::cout << "write clearning" << std::endl;
    //      }
    //    });
    //}
  }


//  std::thread t;
  tcp::socket * socket_;
  std::mutex * socket_mutex;
  enum { max_length = 1024 };
  char data_[max_length];
  std::vector <ap_uint <PACKET_DATA_LENGTH> > vect;
  bool read;
};

class accept_server
{
public:
  accept_server(boost::asio::io_context& io_context, short port, std::mutex * _ip_addrs_mutex, std::vector <boost::asio::ip::tcp::endpoint > * _ip_addrs)
    : acceptor_(io_context, tcp::endpoint(tcp::v4(), port))
  {
   
    ip_addrs = _ip_addrs;
    ip_addrs_mutex = _ip_addrs_mutex;
    do_accept(); 
      
      
    //t_accept = std::make_unique<std::thread>(&server::accept,this);
    //t_recv = std::make_unique<std::thread>(&server::recv,this);
    //t_send = std::make_unique<std::thread>(&server::send,this);
    //t_accept->join();
    //t_recv->detach();
    //t_send->detach();
  }

private:
  void do_accept()
  {
      std::cout << "IN ACCEPT" << std::endl;
      acceptor_.async_accept(
        [this](boost::system::error_code ec, tcp::socket socket)
        {
          if (!ec)
          {
            sockets.push_back(std::move(socket));
            //socket_mutexes.push_back(std::mutex);
            //std::make_shared<session>(std::move(socket))->start();
            std::make_shared<read_session>(&sockets[sockets.size() - 1])->start();
            //std::make_shared<write_session>(&sockets[sockets.size() - 1])->start();
            //{
            //    std::lock_guard <std::mutex> lock(*ip_addrs_mutex);
            //    ip_addrs->push_back(socket.remote_endpoint());

            //}
          }

        std::cout << "IN ACCEPT2" << std::endl;
          do_accept();
        });
  }
  

  std::vector <tcp::socket> sockets; 
  std::vector <std::unique_ptr <read_session> > my_sessions;
  std::mutex * ip_addrs_mutex;
  std::vector <boost::asio::ip::tcp::endpoint > * ip_addrs;
  tcp::acceptor acceptor_;
  galapagos::stream s_axis;
  galapagos::stream m_axis;
};

int main(int argc, char* argv[])
{
  try
  {
    if (argc != 2)
    {
      std::cerr << "Usage: async_tcp_echo_server <port>\n";
      return 1;
    }

    boost::asio::io_context io_context;


    std::vector <boost::asio::ip::tcp::endpoint > ip_addrs;
    std::mutex  ip_addrs_mutex;
    

    accept_server s(io_context, std::atoi(argv[1]), &ip_addrs_mutex, &ip_addrs);

    io_context.run();
  }
  catch (std::exception& e)
  {
    std::cerr << "Exception: " << e.what() << "\n";
  }

  return 0;
}
